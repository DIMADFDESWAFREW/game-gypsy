
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Gypsy Bottle Game ‚Äì Animated</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #gameWrapper {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #000;
    }

    #gameCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #222;
      touch-action: none;
    }

    #hud {
      position: absolute;
      top: 8px;
      left: 10px;
      font-size: 22px;
      color: #fff;
      text-shadow: 0 0 4px #000;
      display: flex;
      gap: 8px;
      align-items: center;
      z-index: 5;
    }

    #hud span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    #startButton {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 14px 32px;
      border-radius: 999px;
      border: none;
      font-size: 20px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, #ffb73a, #ff8c00);
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      cursor: pointer;
      z-index: 10;
    }

    #startButton:active {
      transform: translate(-50%, -50%) scale(0.97);
    }
  </style>
</head>
<body>
<div id="gameWrapper">
  <canvas id="gameCanvas"></canvas>

  <div id="hud">
    <span id="timeLabel">30 s</span>
    <span>üçæ <span id="scoreLabel">0</span></span>
  </div>

  <button id="startButton">–ò–≥—Ä–∞—Ç—å 30 —Å–µ–∫</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const hudTime = document.getElementById('timeLabel');
  const hudScore = document.getElementById('scoreLabel');
  const startButton = document.getElementById('startButton');

  // === –∞–¥–∞–ø—Ç–∞—Ü–∏—è –ø–æ–¥ —ç–∫—Ä–∞–Ω ===
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    joystick.radiusOuter = Math.min(rect.width, rect.height) * 0.17;
    joystick.radiusInner = joystick.radiusOuter * 0.45;
    joystick.baseX = rect.width / 2;
    joystick.baseY = rect.height - joystick.radiusOuter - 20;
  }
  window.addEventListener('resize', resize);
  resize();

  // === –∑–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ä—Ç–∏–Ω–æ–∫ ===
  const mapImg = new Image();
  const playerImg = new Image();
  const bottleImg = new Image();

  mapImg.src = 'assets/city-map.png';
  playerImg.src = 'assets/gypsy.png';
  bottleImg.src = 'assets/bottle.png';

  // –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º: —Å–ø—Ä–∞–π—Ç 3x4 (–≤–Ω–∏–∑, –≤–ª–µ–≤–æ, –≤–ø—Ä–∞–≤–æ, –≤–≤–µ—Ä—Ö)
  const sprite = {
    cols: 3,
    rows: 4,
    frameW: 0,
    frameH: 0
  };

  playerImg.onload = () => {
    sprite.frameW = playerImg.width / sprite.cols;
    sprite.frameH = playerImg.height / sprite.rows;
  };

  // === —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã ===
  const player = {
    x: 0,
    y: 0,
    size: 80,
    speed: 180,          // px / sec
    dir: 'down',         // 'down' | 'up' | 'left' | 'right'
    frameIndex: 1,       // 0..cols-1
    frameTimer: 0,
    frameInterval: 0.12, // —Å–µ–∫—É–Ω–¥—ã –Ω–∞ –∫–∞–¥—Ä
    moving: false
  };

  const joystick = {
    active: false,
    baseX: 0,
    baseY: 0,
    currentX: 0,
    currentY: 0,
    radiusOuter: 100,
    radiusInner: 45,
    normX: 0,
    normY: 0
  };

  const bottles = [];
  let bottleSpawnTimer = 0;
  const bottleSpawnInterval = 0.7;

  let timeLeft = 30;
  let score = 0;
  let running = false;
  let lastTs = 0;

  function resetGame() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    player.x = w / 2;
    player.y = h / 2;
    player.dir = 'down';
    player.frameIndex = 1;
    player.frameTimer = 0;
    player.moving = false;

    bottles.length = 0;
    bottleSpawnTimer = 0;

    timeLeft = 30;
    score = 0;
    hudTime.textContent = `${timeLeft} s`;
    hudScore.textContent = score;
  }

  resetGame();

  // === —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∂–æ–π—Å—Ç–∏–∫–æ–º ===
  function pointerDown(x, y) {
    const dx = x - joystick.baseX;
    const dy = y - joystick.baseY;
    const dist = Math.hypot(dx, dy);
    if (dist <= joystick.radiusOuter * 1.3) {
      joystick.active = true;
      joystick.currentX = x;
      joystick.currentY = y;
      updateJoystickVector();
    }
  }

  function pointerMove(x, y) {
    if (!joystick.active) return;
    const dx = x - joystick.baseX;
    const dy = y - joystick.baseY;
    const maxR = joystick.radiusOuter;
    const dist = Math.hypot(dx, dy);
    if (dist > maxR) {
      const k = maxR / dist;
      joystick.currentX = joystick.baseX + dx * k;
      joystick.currentY = joystick.baseY + dy * k;
    } else {
      joystick.currentX = x;
      joystick.currentY = y;
    }
    updateJoystickVector();
  }

  function pointerUp() {
    joystick.active = false;
    joystick.normX = 0;
    joystick.normY = 0;
  }

  function updateJoystickVector() {
    const dx = joystick.currentX - joystick.baseX;
    const dy = joystick.currentY - joystick.baseY;
    const maxR = joystick.radiusOuter * 0.9;
    const dist = Math.hypot(dx, dy);
    if (dist < 5) {
      joystick.normX = 0;
      joystick.normY = 0;
    } else {
      const k = Math.min(1, dist / maxR);
      joystick.normX = (dx / dist) * k;
      joystick.normY = (dy / dist) * k;
    }
  }

  // touch
  canvas.addEventListener('touchstart', e => {
    const rect = canvas.getBoundingClientRect();
    for (const t of e.touches) {
      pointerDown(t.clientX - rect.left, t.clientY - rect.top);
      break;
    }
  }, {passive: false});

  canvas.addEventListener('touchmove', e => {
    const rect = canvas.getBoundingClientRect();
    for (const t of e.touches) {
      pointerMove(t.clientX - rect.left, t.clientY - rect.top);
      break;
    }
  }, {passive: false});

  canvas.addEventListener('touchend', () => {
    pointerUp();
  });
  canvas.addEventListener('touchcancel', () => {
    pointerUp();
  });

  // mouse (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ –Ω–∞ –ü–ö)
  canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    pointerDown(e.clientX - rect.left, e.clientY - rect.top);
  });
  window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    pointerMove(e.clientX - rect.left, e.clientY - rect.top);
  });
  window.addEventListener('mouseup', () => {
    pointerUp();
  });

  // === –ª–æ–≥–∏–∫–∞ ===
  function update(dt) {
    if (!running) return;

    // —Ç–∞–π–º–µ—Ä
    timeLeft -= dt;
    if (timeLeft < 0) timeLeft = 0;
    hudTime.textContent = `${Math.ceil(timeLeft)} s`;
    if (timeLeft <= 0) {
      running = false;
      return;
    }

    // –¥–≤–∏–∂–µ–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –æ—Ç –¥–∂–æ–π—Å—Ç–∏–∫–∞
    let vx = 0, vy = 0;
    const mag = Math.hypot(joystick.normX, joystick.normY);

    if (mag > 0.15) {
      const nx = joystick.normX / mag;
      const ny = joystick.normY / mag;

      vx = nx * player.speed;
      vy = ny * player.speed;

      // –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è —Å–ø—Ä–∞–π—Ç–∞
      if (Math.abs(vx) > Math.abs(vy)) {
        player.dir = vx > 0 ? 'right' : 'left';
      } else {
        player.dir = vy > 0 ? 'down' : 'up';
      }

      player.moving = true;
    } else {
      player.moving = false;
    }

    // –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
    const rect = canvas.getBoundingClientRect();
    player.x += vx * dt;
    player.y += vy * dt;

    const margin = player.size / 2;
    player.x = Math.max(margin, Math.min(rect.width - margin, player.x));
    player.y = Math.max(margin, Math.min(rect.height - margin, player.y));

    // –∞–Ω–∏–º–∞—Ü–∏—è —à–∞–≥–∞
    if (player.moving) {
      player.frameTimer += dt;
      if (player.frameTimer >= player.frameInterval) {
        player.frameTimer -= player.frameInterval;
        player.frameIndex = (player.frameIndex + 1) % sprite.cols;
      }
    } else {
      player.frameIndex = 1; // —Å—Ä–µ–¥–Ω–∏–π –∫–∞–¥—Ä ‚Äî —Å—Ç–æ–∏–º
      player.frameTimer = 0;
    }

    // –ø–æ—è–≤–ª–µ–Ω–∏–µ –±—É—Ç—ã–ª–æ–∫
    bottleSpawnTimer += dt;
    if (bottleSpawnTimer >= bottleSpawnInterval) {
      bottleSpawnTimer -= bottleSpawnInterval;
      spawnBottle();
    }

    // —Å–±–æ—Ä –±—É—Ç—ã–ª–æ–∫
    for (const b of bottles) {
      if (b.collected) continue;
      const dx = b.x - player.x;
      const dy = b.y - player.y;
      const dist = Math.hypot(dx, dy);
      if (dist < player.size * 0.6) {
        b.collected = true;
        score += 1;
        hudScore.textContent = score;
      }
    }
  }

  function spawnBottle() {
    const rect = canvas.getBoundingClientRect();
    const padding = 40;
    const x = padding + Math.random() * (rect.width - padding * 2);
    const y = padding + Math.random() * (rect.height - padding * 2 - joystick.radiusOuter * 1.6);
    bottles.push({ x, y, collected: false });
  }

  // === –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ ===
  function draw() {
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0, 0, rect.width, rect.height);

    // –∫–∞—Ä—Ç–∞
    if (mapImg.complete && mapImg.naturalWidth > 0) {
      const scale = Math.max(rect.width / mapImg.width, rect.height / mapImg.height);
      const dw = mapImg.width * scale;
      const dh = mapImg.height * scale;
      const dx = (rect.width - dw) / 2;
      const dy = (rect.height - dh) / 2;
      ctx.drawImage(mapImg, dx, dy, dw, dh);
    } else {
      ctx.fillStyle = '#3a3a3a';
      ctx.fillRect(0, 0, rect.width, rect.height);
    }

    // –±—É—Ç—ã–ª–∫–∏
    for (const b of bottles) {
      if (b.collected) continue;
      const size = 40;
      if (bottleImg.complete && bottleImg.naturalWidth > 0) {
        ctx.drawImage(
          bottleImg,
          b.x - size / 2,
          b.y - size / 2,
          size,
          size
        );
      } else {
        ctx.fillStyle = '#8fd1ff';
        ctx.beginPath();
        ctx.arc(b.x, b.y, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // –ø–µ—Ä—Å–æ–Ω–∞–∂
    drawPlayer(rect);

    // –¥–∂–æ–π—Å—Ç–∏–∫
    drawJoystick(rect);
  }

  function drawPlayer(rect) {
    // —Ç–µ–Ω—å
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath();
    ctx.ellipse(player.x, player.y + player.size * 0.35, player.size * 0.35, player.size * 0.18, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    if (playerImg.complete && sprite.frameW > 0 && sprite.frameH > 0) {
      let row = 0;
      switch (player.dir) {
        case 'down':  row = 0; break;
        case 'left':  row = 1; break;
        case 'right': row = 2; break;
        case 'up':    row = 3; break;
      }

      const sx = player.frameIndex * sprite.frameW;
      const sy = row * sprite.frameH;
      const dx = player.x - player.size / 2;
      const dy = player.y - player.size / 2;

      ctx.drawImage(
        playerImg,
        sx, sy, sprite.frameW, sprite.frameH,
        dx, dy, player.size, player.size
      );
    } else {
      // –∑–∞–ø–∞—Å–Ω–æ–π –∫—Ä—É–∂–æ–∫, –µ—Å–ª–∏ —Å–ø—Ä–∞–π—Ç –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è
      ctx.fillStyle = '#ffd54f';
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.size / 2.2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawJoystick(rect) {
    // –≤–Ω–µ—à–Ω–µ–µ –∫–æ–ª—å—Ü–æ
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(joystick.baseX, joystick.baseY, joystick.radiusOuter, 0, Math.PI * 2);
    ctx.fill();

    // –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫—Ä—É–≥
    const innerX = joystick.active ? joystick.currentX : joystick.baseX;
    const innerY = joystick.active ? joystick.currentY : joystick.baseY;

    const grd = ctx.createRadialGradient(
      innerX, innerY, joystick.radiusInner * 0.1,
      innerX, innerY, joystick.radiusInner
    );
    grd.addColorStop(0, '#ffd54f');
    grd.addColorStop(1, '#ff9800');

    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(innerX, innerY, joystick.radiusInner, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // === –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª ===
  function loop(ts) {
    if (!lastTs) lastTs = ts;
    const dt = (ts - lastTs) / 1000;
    lastTs = ts;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // —Å—Ç–∞—Ä—Ç
  startButton.addEventListener('click', () => {
    resetGame();
    running = true;
    startButton.style.display = 'none';
  });

})();
</script>
</body>
</html>
