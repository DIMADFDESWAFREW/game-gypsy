
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Gypsy Bottle Game ‚Äì v2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, sans-serif;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    #gameWrapper {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #000;
    }
    #gameCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #222;
      touch-action: none;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 5;
      display: flex;
      gap: 14px;
      align-items: center;
      font-size: 22px;
      color: #fff;
      text-shadow: 0 0 5px #000;
    }
    #hud span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    #startBtn {
      position: absolute;
      left: 50%;
      top: 45%;
      transform: translate(-50%, -50%);
      padding: 14px 28px;
      border-radius: 40px;
      font-size: 20px;
      font-weight: bold;
      color: #222;
      background: linear-gradient(135deg, #ffd54f, #ff9100);
      border: none;
      z-index: 6;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    }
    #startBtn:active {
      transform: translate(-50%, -50%) scale(0.97);
    }
    #centerMessage {
      position: absolute;
      left: 50%;
      top: 35%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 20px;
      text-align: center;
      text-shadow: 0 0 6px #000;
      z-index: 5;
      pointer-events: none;
    }
    #joystickBase {
      position: absolute;
      left: 50%;
      bottom: 28px;
      transform: translateX(-50%);
      width: 210px;
      height: 210px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #222, #000);
      border: 3px solid rgba(255,255,255,0.12);
      box-shadow: 0 0 16px rgba(0,0,0,0.85);
      z-index: 6;
      touch-action: none;
    }
    #joystickKnob {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 90px;
      height: 90px;
      margin-left: -45px;
      margin-top: -45px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffeb3b, #ff9100);
      box-shadow: 0 0 22px rgba(0,0,0,0.9);
      touch-action: none;
    }
    @media (min-width: 768px) {
      #hud { font-size: 24px; }
      #joystickBase { width: 230px; height: 230px; }
      #joystickKnob { width: 100px; height: 100px; margin-left: -50px; margin-top: -50px; }
    }
  </style>
</head>
<body>
<div id="gameWrapper">
  <canvas id="gameCanvas"></canvas>

  <div id="hud">
    <span><span id="time">30</span>s</span>
    <span>üçæ <span id="score">0</span></span>
  </div>

  <button id="startBtn">–ò–≥—Ä–∞—Ç—å 30 —Å–µ–∫</button>
  <div id="centerMessage"></div>

  <div id="joystickBase">
    <div id="joystickKnob"></div>
  </div>
</div>

<script>
const GAME_TIME = 30;
const PLAYER_SPEED = 210;
const BOTTLE_SIZE = 38;
const MAX_BOTTLES = 10;
const BOTTLE_SPAWN_INTERVAL = 800; // –º—Å
const FRAME_TIME = 120; // –º—Å –º–µ–∂–¥—É –∫–∞–¥—Ä–∞–º–∏ —à–∞–≥–∞

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resize() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
}
window.addEventListener('resize', resize);
resize();

const timeEl = document.getElementById('time');
const scoreEl = document.getElementById('score');
const startBtn = document.getElementById('startBtn');
const centerMessage = document.getElementById('centerMessage');
const joyBase = document.getElementById('joystickBase');
const joyKnob = document.getElementById('joystickKnob');

// --- Sprites ---
const mapImg = new Image();
mapImg.src = 'assets/city-map.png';

const playerImg = new Image();
playerImg.src = 'assets/gypsy.png'; // 3 –∫–∞–¥—Ä–∞ √ó 4 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è

const bottleImg = new Image();
bottleImg.src = 'assets/bottle.png';

const obstacleTopImg = new Image();
obstacleTopImg.src = 'assets/obstacle_top.png';

const obstacleBottomImg = new Image();
obstacleBottomImg.src = 'assets/obstacle_bottom.png';

// --- Game state ---
let player = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  size: 60,
  dir: 0,        // 0-–≤–Ω–∏–∑,1-–≤–ø—Ä–∞–≤–æ,2-–≤–≤–µ—Ä—Ö,3-–≤–ª–µ–≤–æ
  frameIndex: 0, // 0..2
  frameTimer: 0,
  moving: false
};

let sprite = {
  ready: false,
  frameW: 0,
  frameH: 0
};

playerImg.onload = () => {
  sprite.frameW = playerImg.width / 3;
  sprite.frameH = playerImg.height / 4;
  sprite.ready = true;
};

let bottles = [];
let score = 0;
let gameTimeLeft = GAME_TIME;
let isRunning = false;
let spawnTimer = 0;
let lastTs = 0;

// obstacles: –≤–µ—Ä—Ö –∏ –Ω–∏–∑ –≤–æ –≤—Å—é —à–∏—Ä–∏–Ω—É
function getObstacles() {
  const h = canvas.height;
  const w = canvas.width;
  const bandHeight = Math.max(60, h * 0.14);
  return [
    { // top
      x: 0,
      y: 0,
      w: w,
      h: bandHeight
    },
    { // bottom
      x: 0,
      y: h - bandHeight,
      w: w,
      h: bandHeight
    }
  ];
}

// joystick state
let joyActive = false;
let moveVector = { x: 0, y: 0 };

function getJoyRelative(clientX, clientY) {
  const rect = joyBase.getBoundingClientRect();
  return {
    x: clientX - (rect.left + rect.width / 2),
    y: clientY - (rect.top + rect.height / 2),
    maxRadius: rect.width / 2 - joyKnob.offsetWidth / 2
  };
}

function setJoystick(dx, dy, maxR) {
  const dist = Math.hypot(dx, dy);
  if (dist > maxR && dist > 0) {
    const k = maxR / dist;
    dx *= k;
    dy *= k;
  }
  joyKnob.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
  moveVector.x = dx / maxR;
  moveVector.y = dy / maxR;
}

function resetJoystick() {
  joyKnob.style.transform = 'translate(0,0)';
  moveVector.x = 0;
  moveVector.y = 0;
}

// touch controls
joyBase.addEventListener('touchstart', (e) => {
  e.preventDefault();
  joyActive = true;
  const t = e.changedTouches[0];
  const p = getJoyRelative(t.clientX, t.clientY);
  setJoystick(p.x, p.y, p.maxRadius);
}, { passive: false });

joyBase.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (!joyActive) return;
  const t = e.changedTouches[0];
  const p = getJoyRelative(t.clientX, t.clientY);
  setJoystick(p.x, p.y, p.maxRadius);
}, { passive: false });

joyBase.addEventListener('touchend', (e) => {
  e.preventDefault();
  joyActive = false;
  resetJoystick();
}, { passive: false });

// mouse support (–¥–ª—è —Ç–µ—Å—Ç–∞ –Ω–∞ –ü–ö)
joyBase.addEventListener('mousedown', (e) => {
  e.preventDefault();
  joyActive = true;
  const p = getJoyRelative(e.clientX, e.clientY);
  setJoystick(p.x, p.y, p.maxRadius);
});
window.addEventListener('mousemove', (e) => {
  if (!joyActive) return;
  const p = getJoyRelative(e.clientX, e.clientY);
  setJoystick(p.x, p.y, p.maxRadius);
});
window.addEventListener('mouseup', () => {
  if (!joyActive) return;
  joyActive = false;
  resetJoystick();
});

// bottles
function spawnBottle() {
  if (bottles.length >= MAX_BOTTLES) return;
  const marginX = 40;
  const marginY = 80;
  const x = marginX + Math.random() * (canvas.width - marginX * 2);
  const y = marginY + Math.random() * (canvas.height - marginY * 2);
  const obs = getObstacles();
  // avoid spawning inside obstacles
  for (let o of obs) {
    if (x > o.x && x < o.x + o.w && y > o.y && y < o.y + o.h) {
      return;
    }
  }
  bottles.push({ x, y, size: BOTTLE_SIZE });
}

function resetGame() {
  player.x = canvas.width / 2;
  player.y = canvas.height / 2;
  player.dir = 0;
  player.frameIndex = 0;
  player.frameTimer = 0;
  player.moving = false;
  bottles = [];
  score = 0;
  gameTimeLeft = GAME_TIME;
  spawnTimer = 0;
  timeEl.textContent = GAME_TIME.toString();
  scoreEl.textContent = '0';
  centerMessage.textContent = '';
}

// direction from movement
function updateDirectionFromVector(vx, vy) {
  if (Math.abs(vx) < 0.1 && Math.abs(vy) < 0.1) {
    player.moving = false;
    return;
  }
  player.moving = true;
  if (Math.abs(vx) > Math.abs(vy)) {
    player.dir = vx > 0 ? 1 : 3; // 1-–≤–ø—Ä–∞–≤–æ,3-–≤–ª–µ–≤–æ
  } else {
    player.dir = vy > 0 ? 0 : 2; // 0-–≤–Ω–∏–∑,2-–≤–≤–µ—Ä—Ö
  }
}

// simple obstacle collision: keep player above/below bands
function resolveObstacleCollision(oldX, oldY) {
  const obs = getObstacles();
  for (let o of obs) {
    if (
      player.x + player.size/2 > o.x &&
      player.x - player.size/2 < o.x + o.w &&
      player.y + player.size/2 > o.y &&
      player.y - player.size/2 < o.y + o.h
    ) {
      // revert Y first to avoid sticking
      player.y = oldY;
      if (
        player.x + player.size/2 > o.x &&
        player.x - player.size/2 < o.x + o.w &&
        player.y + player.size/2 > o.y &&
        player.y - player.size/2 < o.y + o.h
      ) {
        player.x = oldX;
      }
    }
  }
}

startBtn.addEventListener('click', () => {
  resetGame();
  isRunning = true;
  startBtn.style.display = 'none';
});

// update loop
function update(dt) {
  if (!isRunning) return;

  gameTimeLeft -= dt;
  if (gameTimeLeft <= 0) {
    gameTimeLeft = 0;
    isRunning = false;
    centerMessage.innerHTML = '‚è≥ –í—Ä–µ–º—è –≤—ã—à–ª–æ!<br>–¢—ã —Å–æ–±—Ä–∞–ª: <b>' + score + '</b> –±—É—Ç—ã–ª–æ–∫';
    startBtn.textContent = '–ò–≥—Ä–∞—Ç—å –µ—â—ë 30 —Å–µ–∫';
    startBtn.style.display = 'block';
  }
  timeEl.textContent = Math.ceil(gameTimeLeft).toString();

  // movement
  const len = Math.hypot(moveVector.x, moveVector.y);
  let vx = 0, vy = 0;
  if (len > 0.2) {
    vx = (moveVector.x / len) * PLAYER_SPEED;
    vy = (moveVector.y / len) * PLAYER_SPEED;
  }
  updateDirectionFromVector(vx, vy);

  const oldX = player.x;
  const oldY = player.y;

  player.x += vx * dt;
  player.y += vy * dt;

  const half = player.size / 2;
  if (player.x < half) player.x = half;
  if (player.x > canvas.width - half) player.x = canvas.width - half;
  if (player.y < half) player.y = half;
  if (player.y > canvas.height - half) player.y = canvas.height - half;

  resolveObstacleCollision(oldX, oldY);

  // walk animation
  if (player.moving) {
    player.frameTimer += dt * 1000;
    if (player.frameTimer >= FRAME_TIME) {
      player.frameTimer -= FRAME_TIME;
      player.frameIndex = (player.frameIndex + 1) % 3;
    }
  } else {
    player.frameIndex = 0;
    player.frameTimer = 0;
  }

  // spawn bottles
  spawnTimer += dt * 1000;
  if (spawnTimer >= BOTTLE_SPAWN_INTERVAL) {
    spawnTimer = 0;
    spawnBottle();
  }

  // bottle collisions
  for (let i = bottles.length - 1; i >= 0; i--) {
    const b = bottles[i];
    const dx = player.x - b.x;
    const dy = player.y - b.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < (player.size/2 + b.size/2) * 0.8) {
      bottles.splice(i, 1);
      score++;
      scoreEl.textContent = score.toString();
    }
  }
}

// draw loop
function draw() {
  // background map
  if (mapImg.complete && mapImg.naturalWidth > 0) {
    ctx.drawImage(mapImg, 0, 0, canvas.width, canvas.height);
  } else {
    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // obstacles
  const obs = getObstacles();
  obs.forEach((o, idx) => {
    const img = idx === 0 ? obstacleTopImg : obstacleBottomImg;
    if (img.complete && img.naturalWidth > 0) {
      ctx.drawImage(img, o.x, o.y, o.w, o.h);
    } else {
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(o.x, o.y, o.w, o.h);
    }
  });

  // bottles
  bottles.forEach(b => {
    if (bottleImg.complete && bottleImg.naturalWidth > 0) {
      ctx.drawImage(bottleImg, b.x - b.size/2, b.y - b.size/2, b.size, b.size);
    } else {
      ctx.fillStyle = '#8bc34a';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size/2, 0, Math.PI * 2);
      ctx.fill();
    }
  });

  // player
  if (sprite.ready) {
    const fw = sprite.frameW;
    const fh = sprite.frameH;
    const sx = player.frameIndex * fw;
    const sy = player.dir * fh;
    ctx.drawImage(
      playerImg,
      sx, sy, fw, fh,
      player.x - player.size/2,
      player.y - player.size/2,
      player.size, player.size
    );
  } else if (playerImg.complete && playerImg.naturalWidth > 0) {
    ctx.drawImage(
      playerImg,
      player.x - player.size/2,
      player.y - player.size/2,
      player.size, player.size
    );
  } else {
    ctx.fillStyle = '#ffd54f';
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.size/2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// main loop
function loop(ts) {
  if (!lastTs) lastTs = ts;
  const dt = (ts - lastTs) / 1000;
  lastTs = ts;

  update(dt);
  draw();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
